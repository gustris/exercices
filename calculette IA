class Calculatrice:
    def __init__(self):
        self.stack = []

    def push(self, value):
        self.stack.append(value)

    def pop(self):
        return self.stack.pop()

    def evaluate_expression(self, expression):
        operators = {
            '+': lambda x, y: x + y,
            '-': lambda x, y: x - y,
            '*': lambda x, y: x * y,
            '/': lambda x, y: x / y,
            '^': lambda x, y: x ** y
        }

        # Diviser l'expression en une liste de termes
        terms = expression.split()

        # Parcourir les termes et effectuer les opérations
        for i in range(len(terms)):
            term = terms[i]

            if term.isdigit():
                self.push(int(term))
            elif term in operators:
                if i + 1 < len(terms) and terms[i + 1] in operators:
                    # Si le prochain terme est également une opération, prioriser l'opération actuelle
                    operator = operators[term]
                    next_operator = operators[terms[i + 1]]
                    priority = operator.__name__.find('binary') // 4
                    next_priority = next_operator.__name__.find('binary') // 4

                    if priority < next_priority:
                        # Prioriser l'opération suivante
                        self.push(self.pop())
                        i += 1

                operator = operators[term]
                second_operand = self.pop()
                first_operand = self.pop()
                result = operator(first_operand, second_operand)
                self.push(result)
            else:
                raise ValueError("Invalid term")

        return self.pop()


# Exemple d'utilisation
calculator = Calculatrice()
expression = "2 + 3 * 4 - 1"
result = calculator.evaluate_expression(expression)
print(result)  # Affiche: 17
